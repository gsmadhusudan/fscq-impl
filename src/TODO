Replace block addrs with fixed-range Z's.

Replace block values with 512-byte units.

What should we do about non-determinism in the high-level (source) language?
  We want non-determinism: e.g., return any FD, any mmap addr, any block, any inode.
  But then forward simulation doesn't work because only one choice is possible in
  the target (deterministic) language.  Potential soln: backward simulation directly,
  without going through fsim.  But how difficult is this?

Perhaps cleanly represent the following refinement pattern:
  state remains the same
  some operations remain the same, with the same semantics
  some operations are removed
  some operations are introduced, with new semantics
  (e.g., BmapAllocOne -> BmapAllocAll)

Do we really need Free in InodeAlloc?  InodeRW writes Avail to the inode anyway.

Non-determinism comes up again: when does growing a file fail (InodeRW)?
  Making grow failure deterministic requires putting the blockmap allocator state
  in InodeRW, even though it's not really that interesting/relevant there.

It's annoying having to implement cases that are undefined behavior in semantics.
  E.g., InodeRW.Shrink requires len to be a particular value, but the Compile
  function cannot reason about this, and has to handle any len..

